\chapter{Теоретическая часть}
\section{Введение в основные понятия} % 2 Preliminaries
В данной работе, $\lambda$ обозначает параметр безопасности.
Для целого положительного числа $N$, $[N]$ обозначает набор целых положительных чисел $\{1, 2, \dots, N\}$.
Для двух целых положительных чисел $a$ и $b$, таких что, $a < b$, запись $[a, b]$ обозначает набор целых положительных чисел $\{a, a + 1, \dots, b\}$.
Будем называть алгоритм эффективным, если по отношению к $\lambda$ он работает за полиномиальное время.
Величину, обратно пропорциональную полиномиальному значению по отношению к $\lambda$, назовем незначительной.
Для двух распределений $D_1$ и $D_2$ по одной и той де области будем писать $D_1 \approx D_2$, чтобы обозначить вычислительную неразличимость; а именно, для любого сколь угодно эффективного противника, который получает на вход образец и выводит по нему бит, разница в вероятности того, что противник выведит $1$ при получении образца из $D_1$, и вероятности того, что противник выведит $1$ при получении образца из $D_2$, незначительна.
Вышеуказанную величину назовем преимуществом противника в различении $D_1$ и $D_2$.

Обозначим битовую строку произвольной длины как $\{0, 1\}^*$.
Операцию конкатенации строк обозначим как $||$.
Для целого положительного числа $n$, обозначим упорядоченную последовательность набора элементов $\{a_1, \dots, a_n\}$ как $\langle a_1, \dots, a_n \rangle$.

Запись $y_{i, 1}, \dots, y_{i, d}$ обозначает представление целого положительного $d$-значного числа $y_i$ по основанию $b$.

\subsection{Доказательство диапазона на основе удостоверений} % 2.1 Credential-Based Range Proofs
Для фиксированного целого положительного числа $N$, пространства обязательств $\C$, пространства доказательст $\P$ и пространства случайнойсти $\{0, 1\}^\lambda$, неинтерактивный CBRP представляет собо набор алгоритмов $\Pi = (\Setup, \Commit, \Prove, \Verify)$ со следующими свойствами:
- $\Setup(1^\lambda) \rightarrow \pp$. Алгоритм установки на основе параметра безопасности $\lambda$ генерирует публичные параметры $\pp$.
- $\Commit(\pp, x; r) \rightarrow \com$. Алгоритм обязательства на основе публичных параметров $\pp$, целого положительного числа $x \in [N]$ и случайной битовой строки $r \in \{0, 1\}^\lambda$ генерирует обязательство $\com \in \C$.
- $\Prove(\pp, x, t; r) \rightarrow \pi$. Алгоритм доказательства на основе публичных параметров, целого положительного числа $x$, порогового значения $t \in [N]$ и случайной битовой строки $r \in \{0, 1\}^\lambda$ генерирует доказательство $\pi$.
- $\Verify(\pp, \com, t, \pi) \rightarrow z$. Алгоритм проверки на основе публичных параметров, обязательства $\com \in C$, порогового значения $t \in [N]$ и доказательства $\pi$ генерирует бит $z \in \{0, 1\}$.

% TODO: Security

\begin{definition}[Навязывающее обязательство]
	Обязательство для $CBRP$ назвыается навязывающим если для любого сколь угодно эффективного злоумышленника $\A$, который получает публичные параметры $\pp \leftarrow \Setup(1^\lambda)$ и генерирует пару раличных целых положительных чисел $x_0, x_1 \in [N]$, пару случйаный битовых строк $r_0, r_1 \in \{0, 1\}^\lambda$ и два обязательства $\com_0 \leftarrow \Commit(\pp, x_0; r_0)$ и $\com_1 \leftarrow \Commit(\pp, x_1; r_1)$, величина $Pr[\com_0 = \com_1]$ незначительна по отношению к $\lambda$.
\end{definition}

\begin{definition}[Идеальная полнота]
	CBRP удовлетворяет идеальной полноте если любой сколь угодно эффективный злоумышленник $\A$, генерирующий $x, t \in [N]$, причем  $x \geq t$, и $r \in \{0, 1\}^\lambda$, будет получать $\Verify(\Commit(x; r), t, \Prove(x, t; r)) = 1$.
\end{definition}

\begin{definition}[Обязательно-условная корректность]
	\label{definition:3}
	CBRP удовлетворяет обязательно-условной корректности если для любого сколь угодно эффективного злоумышленника $\A$, который на основе публичных параметров $\pp \leftarrow \Setup(1^\lambda)$ генерирует набор $(x, t, r, \pi) \in [N] \times [N] \times \{0, 1\}^\lambda \times \P$, где $x < t$, вероятность $\Verify(\pp, \Commit(\pp, x; r), t, \pi) = 1$ незначительна по отношению к $\lambda$.
\end{definition}

Стоит заметить, что данное определение является более слабым по сравнению с традиционным определением корректности для систем доказательства диапазона.
В классическом подходе для обеспечения надежности злоумышленнику предоставляется возможность сгенерировать обязательство $\com$, пороговое значение $t$ и доказательство $\pi$.
Атака считается неуспешной, если выполняется условик $\Verify(\com, t, \pi) = 1$ и при этом не существует пары $(x, r) \in [N] \times \{0, 1\}^\lambda$, для которой выполняется равенство $\com = \Commit(x; r)$ при $x \geq t$.
Однако в данном случае, возможности злоумышленника ограничиваются тем фактом, что проверяющий не может получить недействительное обязательство.

\begin{definition}[$\ExptWI$]
	Для положительного целого числа $N$ эксперимент $\ExptWI_b(\A)$ между доверенным лицом и злоумышленником $\A$ осуществляется следующим образом:
	\begin{enumerate}
		\item Доверенное лицо отправляет публичные параметры $\pp \leftarrow \Setup(1^\lambda)$ злоумышленнику $\A$.
		\item Злоумышленник $\A$ отправляет доверенному лицу $x, t \in [N]$, где $x \geq t$.
		\item Доверенное лицо выбирает случайную битовую строку $r \leftarrow_R \{0, 1\}^\lambda$ и генерирует $(\com_b, \pi_b) \leftarrow (\Commit(x_b; r), \Prove(x_b, t; r))$ для злоумышленника $\A$.
		\item Злоумышленник $\A$ генерирует один бит, который является результатом эксперимента.
	\end{enumerate}
\end{definition}

\begin{definition}[Неразличимость свидетелей]
	CBRP удовлетворяет неразличимости свидетелей, если для любого сколь угодно эффективного злоумышленника $\A$ величина $\Pr[\ExptWI_0(\A) = 1] - \Pr[\ExptWI_1(\A)=1]$ незначительна по отношению к $\lambda$.
\end{definition}

CBRP является безопасной, если все вышеперечисленные свойства: навязывающее обязательство, полнота, корректность и неразличимость свидетелей, выполняются.
Традиционные схемы обязательств также требуют свойства сокрытия, однако данное определение опущено, посколько оно подразумевается свойством неразличимости свидетелей, которое является более строгим понятием.

\subsection{Случайные хеш-функции} % 2.2 Random-Output Hash Functions
В данной работе рассматриваются хеш-функции, который удовлетворяют требованиям безопасной случайности.

\begin{definition}[Случайная хеш-функция]
	Пусть $U$ - равномерное распределение на $\{0, 1\}^\lambda$.
	Для целого положительного числа $d$, обозначим $H_d(U)$ распределение следующего вида: $\{H(x): x \leftarrow_R \{0, 1\}^d\}$.
	Будем называть хеш-функцию $H$: $\{0, 1\}^* \rightarrow \{0, 1\}^\lambda$ безопасно случайной, если $H_d(U) \approx U$ для любого $d \geq \lambda$.
\end{definition}

Любая хеш-функция, которую можно смоделировать как случайный оракул, также безопасно случайна.
Однако следует отметить, что безопасная случайность и стойкость к коллизиям для хеш-функция являются неравнозначными.
Для некоторой устойчивой к коллизим хеш-функции $G$: $\{0, 1\}^* \rightarrow \{0, 1\}^{\lambda - 1}$, функция $H$, определенная как $H(x) := 0 || G(x)$ также устойчива к коллизиям, но не удовлетворяет условию безопасной случайности.
Аналогично, для удовлетворяющей безопасной случайности хеш-функции $F$: $\{0, 1\}^* \rightarrow \{0, 1\}^\lambda$, хеш-функция $H$, определенная как
$$
H(x) :=
\begin{cases}
	0, & \text{если } x = 0^\lambda \text{ или } x = 0^{\lambda + 1} \\
	F(x), & \text{иначе}
\end{cases}
$$
также безопасно случайна, но не устойчива к коллизиям.

\begin{definition}[Псевдослучайный генератор]
	Функция $G$: $\X \rightarrow \Y$, где $|\Y| > |\X|$ является псевдослучайным генератором, если распределение, создаваемое ей, для случайно выбранного $x \leftarrow_R \X$ неотличимо от случайно выбранного $y \leftarrow_R \Y$.
\end{definition}

\subsection{Аккумуляторы} % 2.3 Accumulators
Для области $\X$ и пространства $\Y$, аккумулятор $\ACC = (\Setup, \Eval, \WitCreate, \Verify)$ это набор алгоритмов, определяемых следующим образом:
\begin{itemize}
	\item $\Setup(1^\lambda) \rightarrow \pp$. Алгоритм подготовки на основе параметра безопасности $\lambda$ генерирует публичные параметры $\pp$.
	\item $\Eval(\pp, S) \rightarrow \acc$. Алгоритм оценки на основе публичных параметров $\pp$ и подмножества $S \subseteq \X$ генерирует аккумуляцию $\acc$.
	\item $\WitCreate(\pp, x, S) \rightarrow \wit$. Алгоритм создания свидетеля на основе публичных параметров, элемента $x \in \X$ и подмножества $S \subseteq \X$ генерирует свидетельство $\wit$.
	\item $\Verify(\pp, \acc, \wit, x) \rightarrow b$. Алгоритм проверки на основе публичных параметров $\pp$, аккумуляции $\acc \in \Y$, свидетельства $\wit$ и элемента $x \in \X$ генерирует бит $b \in \{0, 1\}$, представляющий собой результат успешности проверки.
\end{itemize}

% TODO: посмотреть определения из источника и возможно выписать их
Используя терминологию из \cite{cryptoeprint:2015/087}, будут рассматриваться статические аккумуляторы, которые являются неуниверсальными, то есть поддерживают только доказательства включения, и детерминированными.
Также алгоритм создание свидетелей несколько изменен, что позволяет ему принимать множество $S$ вместо аккумуляции и вспомогательной строки, как это сделано в \cite{cryptoeprint:2015/087}.
Хотя это и является незначительной утратой общности, это упрощает представление основной конструкции, не влияя на функциональность и безопасность протокола.

\begin{definition}[Корректность аккумулятора]
	Аккумулятор корректен, если при входных параметров $\pp \leftarrow \Setup(1^\lambda)$ для любого подмножества $S \subseteq \X$ и $x \in S$ выполняется равенство
	$$
	\Verify(\pp, \Eval(\pp, S), \WitCreate(\pp, x, S), x) = 1
	$$
\end{definition}

\begin{definition}[$\ExptACC$]
	Эксперимент $\ExptACC(\A)$ между злоумышленником $\A$ и доверенным лицом определяется следующим образом:
	\begin{enumerate}
		\item Доверенное лицо отправляет $\pp \leftarrow \Setup(1^\lambda)$ злоумышленнику $\A$.
		\item Злоумышленник $\A$ отправляет свидетельство $\wit$, элемент $x \in \X$ и подмножество $S \subseteq \X$ доверенному лицу.
		\item Доверенное лицо вычисляет $\acc \leftarrow \Eval(\pp, S)$ и генерирует один бит - результат эксперимента, равный $1$ если $x \notin S$ и $\Verify(\pp, \acc, \wit, x) = 1$, или $0$ иначе.
	\end{enumerate}
\end{definition}

\begin{definition}[Безопасный аккумулятор]
	Аккумулятор $\ACC$ считается безопасным, если для сколь угодно эффективного злоумышленника $\A$ величина $\Pr[\ExptACC(\A) = 1]$ является незначительной по отношению к $\lambda$.
\end{definition}

\subsection{Минимальное доминирующее разбиение} % 2.4 Minimum Dominating Partitions
\begin{definition}[Доминирование]
	Для основания $b$ и двух целых положительных чисел $x, y \in \Z^+$, пусть $x = x_1 x_2 \dots x_d$ и $y = y_1 y_2 \dots y_d$ представляют их соответствующее разложение по основанию $b$, где $d = \lceil \log_b(\max(x, y) + 1) \rceil$.
	$x$ "доминирует" над $y$, если $x_i \geq y_i$ для каждого $i \in [d]$ \cite{BonehShoup2023}.
\end{definition}

\begin{definition}[Доминирующее разбиение]
	Для основния $b$ и целого положительного $x \in \Z^+$ доминирующее разбиение $DP_b(x)$ определяется как упорядоченная последовательность целых положительных чисел, удовлетворяющая следующим свойствам:
	\begin{itemize}
		\item Наибольшим элементом из $DP_b(x)$ является $x$.
		\item Для любого $y \in [0, x]$ $\exists z \in DP_b(x)$, для которого $z$ доминирует над $y$ по основанию $b$.
	\end{itemize}
\end{definition}

\begin{definition}[Минимальное доминирующее разбиение]
	Доминирующее разбиение для $x$ по основанию $b$ с наименьшим количество элементов является минимальным и обозначается $\MDP_b(x)$.
\end{definition}

% TODO: Пример

В общем случае для построения минимального доминирующего разбиения для целого положительного числа $x \in [N]$ существует эффетивно вычислимый \ref{alg:1}.

\begin{algorithm}
    \caption{Вычисление $\MDP_b(x)$}
    \label{alg:1}
    \begin{algorithmic}
        \STATE Пусть $d \leftarrow \lceil \log_b(x+1) \rceil$
        \STATE Инииализировать $\sigma \leftarrow [x]$
        \FOR{$i$ от $1$ до $d - 1$}
            \IF{$(x + 1) \mod b^i \neq 0$}
                \STATE $y_i \leftarrow \lfloor \frac{x}{b^i} \rfloor \cdot b^i - 1$
                \STATE $\sigma \leftarrow \sigma \cup \{y_i\}$
            \ENDIF
        \ENDFOR
        \STATE \textbf{Вернуть} $\sigma$
    \end{algorithmic}
\end{algorithm}

Для двух любых целых положительных чисел $x$ и $b$ пусть $\sigma \leftarrow \MDP_b(x)$ будет результатом \ref{alg:1}.
Докажем, что $\sigma$ является минимальным доминирующим разбиением для $x$ по основанию $b$.
Для этого обозначим $d = \lceil \log_b(x + 1) \rceil$, $y_0 = x$ и $y_i \leftarrow \lfloor \frac{x}{b^i} \rfloor \cdot b^i - 1$ для каждого $i \in [d - 1]$.

\begin{theorem}
	\label{lemma:1}
	Для каждого $i \in [d - 1]$ $x$ доминирует над $y_i$ тогда и только тогда, когда $x + 1 \equiv 0 \mod b^i$.
\end{theorem}

\begin{proof}
	По определению цифры $y_{i, d - i + 1}, \dots, y_{i, d}$ все равны $b - 1$ и $y_{i, d - i} \equiv x_{d - 1} - 1 \mod b$, а остальные цифры идентичны между $x$ и $y_i$.
	$x$ доминирует над $y_i$ тогда и только тогда, когда все $x_{d - i + 1} \dots x_d$ также равны $b - 1$.
	Следовательно, $x$ доминирует над $y_i$ только и только тогда, когда $y_i + b^i = x$.
	Зафиксировав $y_i$, мы получаем $\lfloor \frac{x}{b^i} \rfloor \cdot b^i - 1 + b^i = b^i \left( \lfloor \frac{x}{b_i} \rfloor + 1 \right) - 1 = x$, что доказывает теорему.
\end{proof}

\begin{theorem}
	\label{lemma:2}
	Для двух любых различных элементов элементов $z_1, z_2 \in \sigma$, $z_1$ не доминирует над $z_2$.
\end{theorem}

\begin{proof}
	Предположим, что существует пара $z_1, z_2 \in \sigma$ такая, что $z_1 \neq z_2$ и $z_1$ доминирует над $z_2$.
	Пусть $j \in [0, d - 1]$ - минимальный индекс, такой что $z_1 = y_j$.
	\begin{itemize}
		\item Если $z_1 = x$, то $z_2 = y_i$ для некоторого $i \in [1, d - 1]$. По \ref{lemma:1}заключаем, что на итерации $i$ выполняется $x + 1 \equiv 0 \mod b^i$. Следовательно, $z_2 = n_i$ не добавляется в $\sigma$, что противоречит изначальному условию $z_2 \in \sigma$.
		\item Если $z_1 \neq x$, то $z_1 = y_j$ и $z_2 = y_i$ для некоторых $1 \leq j < i \leq d - 1$. По построению $y_{i, d - i + 1} \dots y_{i, d}$ равны $b - 1$. Доминирование $y_j$ над $y_i$ также означает, что $y_{j, d - i + 1} \dots y_{j, d}$ равны $b - 1$. Обратим внимание, что $y_{j - 1} > y_j$ и они могут отличаться только по индексам $d - j$ и $d - j + 1$. Кроме того. $d - i + 1 \geq d - j$, так как $j < i$, и следовательно, $y_{j, d - j}$ и $y_{j - 1, d - j}$ равны $b - 1$. Это означает, что $y_{j - 1} = y_j$, что противоречит условию максимальности индекса $j$.
	\end{itemize}
	В обоих случаях мы приходим к противоречию, что доказывает теорему.
\end{proof}

\begin{theorem}
	\label{lemma:3}
	$\sigma$ является доминирующее разбиение для целого положительного числа $x$ по основанию $b$.
\end{theorem}

\begin{proof}
	По определению, наибольший элемент из $\sigma$ является сам $x$.
	Для доказательства необходимо показать, что для любого целого положительного числа $z \in [0, x - 1]$ существует такой индекс $i$, что $y_i \leftarrow \lfloor \frac{x}{b^i} \rfloor \cdot b^i - 1$ доминирует над $z$.
	Пусть $k$ - наименьший индекс такой, что $z_k > x_k$, а $j \in [1, k - 1]$ - наибольший индекс такой, что $z_j < x_j$.
	Докажем, что $y_{d - j} = \lfloor \frac{x}{b^{d - j}} \rfloor \cdot b^{d - j} - 1$ доминирует над $z$.
	Элементы $y_{d - j, j + 1} \dots y_{d - j, d}$ равны $b - 1$, а значит $y_l \geq z_l$ для всех $l \in [j + 1, d]$.
	Поскольку индекс $k$ минимален и $j < i$, $x_1 \dots x_j$ доминирует над $z_1 \dots z_j$.
	В сочетании с тем фактом, что $y_{d - j, t} = x_t$ для всех $t \in [1, j - 1]$, получаем $y_{d - j, t} \geq z_k$ для данных индексов.
	Наконец, $y_{d - j, j} = x_j - 1$, и поскольку $z_{d - j, j} < x_j$, из этого следует, что $y_{d - j, j} \geq z_j$.
	Таким образом, посколько $y_{d - j}$ добавляется в $\sigma$ на $(d - j)$-той итерации \ref{alg:1}, данное число доминирует над $z$, что завершает доказательство теоремы.
\end{proof}

\begin{theorem}
	\label{theorem:1}
	Для любых двух целых положительных чисел $x$ и $b$ возвращаемое $\MDP_b(x)$, определенной в \ref{alg:1}, множество является минимальным доминирующим разбиением для $x$ по основанию $b$.
\end{theorem}

\begin{proof}
	 По \ref{lemma:3}, $\MDP_b(x)$ является доминирующием разбиением для целого положительного числа $x$ по основанию $b$.
	Предположим, что существует меньшее доминирующее разбиение $\OPT_b(x)$, такое что $|\OPT_b(x)| < |\MDP_b(x)|$.
	По принципи Дирихле, существует некоторый элемент $y \in \OPT_b(x)$, который доминирует над двумя различными элементами $z, w \in \MDP_b(x)$.
	Рассмотрим два случая:
	\begin{itemize}
		\item $z$ доминирует над $y$. Тогда, посколько $y$ также доминирует над $w$, по принципу транзитивности имеем, что $z$ доминирует над $w$, что противоречит \ref{lemma:2}.
		\item $z$ не доминирует над $y$. Тогда должен существовать некоторый другой элемент $v \in \MDP_b(x)$, который доминирует над $y$, и по принципу транзитивности $v$ доминирует над $z$, что противоречит \ref{lemma:2}.
	\end{itemize}
	Противоречия доказывают, что нее существует другого доминирующего разбиения с меньшим количеством элементов, а значит $\MDP_b(x)$ является минимальным доминирующим разбиением.
\end{proof}

% 2.5 Efficient Hashchains
\begin{definition}[Обязательство хеш-цепи]
Пусть $G$ и $H$ - две устойчивые к коллизиям хеш-функции.
Для целого положительного числа $k$, обязательство для хеш-цепи длины $k$ со случайной битовой строкой $r$ определяется как $H^k(G(r))$.
\end{definition}

\begin{definition}[Доказательство хеш-цепи]
Для целого положительного пороговоего значения $t$, доказывающий может предоставить доказательство $\pi = H^{k - t}(G(r))$ проверяющему, которое будет принято, если $k \geq t$.
\end{definition}

\begin{definition}[Обязательство составной хеш-цепи]
	Пусть $N$ - целое положительное число, $b$ - основание, $d = \lceil \log_b(N) \rceil$ и $k_1 \dots k_d = k$ представляет собой разложение $k$ по основанию $b$.
	Для случайной битовой строки $r$ обязательство составной хеш-цепи длины $d$ обозначается $HMC_d(k; r)$ и определяется как конкатенация следующих значений:
	$$
	HMC_d(k; \langle r_1, \dots, r_d \rangle) := H(H^{k_1}(r_1) || \dots || H^{k_d}(r_d))
	$$
\end{definition}

\begin{definition}[Доказательство составной хеш-цепи]
	Для целого положительного порогового значения $t = t_1 \dots t_d$ доказывающий может предоставить доказательство составной хеш-цепи $\pi = H^{k_1 - t_1}(r_1) || \dots || H^{k_d - t_d}(r_d)$, которое доказывает, что $t \in [0, k]$ при условии, что $k$ доминирует над $t$, поскольку в противном случае $k_i - t_i$ не будет являться положительным для всех $1 \leq i \leq d$.
\end{definition}

\begin{definition}[$\HWS_d$]
	Для целого положительного числа $d$ и битовой строки $r \in \{0, 1\}^\lambda$ алгоритм $\HWS_d$, принимающий на вход целое положительное число $k$ и возвращающий перестановку $P: [d] \rightarrow [d]$ и пару последовательностей, каждая из которых состоит из $d$ элементов множества $\{0, 1\}^\lambda$, выполянется следующим образом:
	\begin{enumerate}
		\item Для каждого $i, j \in [d]$ вычисляется $r_{i, j} \leftarrow H((i, j) || r)$. Также используется $r$ и $H$ для получения псевдослучайной перестановки $P$: $[d] \rightarrow [d]$.
		\item Вычисляется $\langle w_1, \dots, w_m \rangle \leftarrow \MDP_b(k)$. Для каждого $i \in [m]$ вычисляется $a_i \leftarrow HMC_d(w_i, \langle r_{i, 1}, \dots, r_{i, d} \rangle)$ и выбирается $d - m$ случайных значений $a_{m + 1}, \dots, a_d \leftarrow_R \{0, 1\}^\lambda$.
		\item Для каждого $i \in [d]$ определяется $c_i \leftarrow a_{P(i)}$. Результатом является $(P, \langle c_1, \dots, c_d \rangle, \langle r_{1, 1}, \dots, r_{d, d} \rangle)$.
	\end{enumerate}
\end{definition}

Длина хеш-цепей, неявно определяемых $\HWS_d(k; r)$, логарифмеческая по отношению $k$ и линейна по его представлению.
Применение конструкции хеш-цепи PayWord \cite{10.1007/3-540-62494-5_6} дало бы хеш-цепь линейной длины по отношению к $k$ и экспоненциальной к его представлению.

\section{Основная конструкция} % 3 The HashWires Construction
\begin{definition}[Основная конструкция]
	Пусть $N$ - целое положительное число, $b$ - основание, $G$: $\{0, 1\}^* \rightarrow \{0, 1\}^\lambda$ и $H$: $\{0, 1\}^* \rightarrow \{0, 1\}^\lambda$ - пара случайных хеш-функций, $\ACC = (\ACC.\Setup, \ACC.\Eval, \ACC.\WitCreate, \ACC.\Verify)$ - безопасный аккумулятор.
	Основная конструкция $\HW = (\HW.\Setup, \HW.\Commit, \HW.\Prove, \HW.\Verify)$ определяется следующим образом:
	\begin{itemize}
		\item $\HW.\Setup(1^\lambda) \rightarrow \pp$. Алгоритм установки на основе параметра безопасности $\lambda$ генерирует публичные параметры $\pp = (\pp_\ACC, N, b, d)$, где $\pp_\ACC \leftarrow \ACC.\Setup(a^\lambda)$, $d = \lceil \log_g(g)g\rceil$.
		\item $\HW.\Commit(\pp, x; r) \rightarrow \com$. Алгоритм обязательства на основе публичных параметров $\pp = (\pp_\ACC, N, b, d)$, целого положительного числа $x \in [N]$ и случайной битовой строки $r$ генерирует $\com \leftarrow \ACC.\Eval(\pp_\ACC, \{c_1, \dots, c_d\})$, где $c_1, \dots, c_d$ - это элементы из $(P, \langle c_1, \dots, c_d \rangle, \langle r_{1, 2}, \dots, r_{d, d} \rangle) \leftarrow \HWS_d(x; r)$.
		\item $\HW.\Prove(\pp, x, r; r) \rightarrow \pi$. Алгоритм генерации доказательства на основе публичных параметров $\pp = (\pp_\ACC, N, b, d)$, целого положительного числа $x \in [N]$, порогового значения $t \in [N]$ и случайной битовой строки $r \in \{0, 1\}^\lambda$ генерирует $\pi = (\wit, \langle v_1, \dots, v_d \rangle)$, где $\wit = \ACC.\WitCreate(\pp_\ACC, c_{P(i^*)}, \{c_1, \dots, c_d\})$, $(P, \langle c_1, \dots, c_d \rangle, \langle r_{1, 1}, \dots, r_{d, d} \rangle) \leftarrow \HWS_d(x; r)$, $\langle w_1, \dots, w_m \rangle \leftarrow \MDP_b(x)$, $i^* \in [m]$ - наименьший индекс, для которого $w_{i^*}$ доминирует над $t$, $v_j \leftarrow H^{y_j - t_j}(r_{i^*, j})$ для $y_1 \dots y_d$ и $t_1 \dots t_d$ как разбиения по основанию $b$ $w_{i^*}$ и $t$ соответственно.
		\item $\HW.\Verify(\pp, \com, t, \pi) \rightarrow z$. Алгоритм проверки на основе публичных параметров $\pp = (\pp_\ACC, N, b, d)$, обязательства $\com$, порогового значения $t \in [N]$ и его разложению $t_1 \dots t_d$ по основанию $b$ и доказательства $\wit = (\wit, \langle v_1, \dots, v_d \rangle)$ генерирует один бит $z \leftarrow \ACC.\Verify(\pp_\ACC, \com, \wit, c^*)$, где $c^* \leftarrow H(H^{t_1}(v_1) || \dots || H^{t_d}(v_d)$.
	\end{itemize}
\end{definition}

\begin{theorem}
	\label{lemma:4}
	Основная конструкция $HW$ удовлетворяет идеальной полноте.
\end{theorem}

\begin{proof}
	Пусть $y_1 \dots y_d$ представление по основанию $b$ некоторого элемента из $\MDP_b(x)$, доминирующего над $t = t_1 \dots t_d$, так как $x \geq t$.
	Идеальная полнота следует из определения доказательства и его определения значений $v_1, \dots, v_d$.
	Так как проверяющий вычисляет $c^* \leftarrow H(H^{t_1}(v_1) || \dots || H^{t_d}(v_d))$, где $v_j = H^{y_j - t_j}(r_{i^*, j})$, то из этого следует, что набор $\{c_1, \dots, c_d\}$ совпадает с набором, для которого $\ACC.\Eval$ генерирует $\com$.
	И значит, благодаря корректности аккумулятора, получаем $\HW.\Verify(\pp, \HW.\Commit(\pp, x; r), t, \HW.\Prove(x, t; r)) = 1$.
\end{proof}

\begin{theorem}
	\label{lemma:5}
	Основная конструкция $\HW$ удовлетворяет свойству навязывающего обязательства, при условии, что $H$ - устойчивая к коллизиям хеш-функция и $\ACC$ - безопасный аккумулятор.
\end{theorem}

\begin{proof}
	По определению навязывающего обязательства, для доказательства необходимо показать, что для двух различных целых положительных чисел $x_0, x_1 \in [N]$, вероятность совпадения из обязательств незначительна.
	Предположим, что $\HW.\Commit(\pp, x_0; r_0) = \com = \HW.\Commit(\pp, x_1; r_1)$.
	Пусть $(P^{(z)}, \langle c_1^{(z)}, \dots, c_d^{(z)} \rangle, \langle r_{1, 1}^{(z)}, \dots, r_{d, d}^{(z)} \rangle) \leftarrow \HWS_d(x_0; r_0)$ и $C^{(z)} = \{c_1^{(z)}, \dots, c_d^{(z)}\}$ для $z \in \{0, 1\}$.
	Рассмотрим два случая:
	% TODO: дописать
\end{proof}

\begin{definition}[$E_0(\A)$ и $E_1(\A)$]
	\begin{itemize}
		\item Эксперимент $E_0(\A)$ генерирует $z \leftarrow \Verify(\pp, \com, t, \pi)$, где $pp \leftarrow \Setup(1^\lambda)$, $(x, t, r, \pi) \leftarrow \A(\pp)$ и $\com \leftarrow \Commit(\pp, c; r)$.
		\item Эксперимент $E_1(\A)$ генерирует 
		$$
		z =
		\begin{cases}
		0 & \text{если } H(H^{t_1}(v_1) || \dots || H^{t_d}(v_d)) \rightarrow c^* \notin C \\
		\Verify(\pp, \com, t, \pi) & \text{иначе}
		\end{cases}
		$$
		где $(x, t, r, \pi) \leftarrow \A(\pp)$, $\pp = (\pp_\ACC, N, b, d) \leftarrow \Setup(1^\lambda)$, $(\wit, \langle c_a, \dots, v_d \rangle) \leftarrow \pi$, $C = \{c_1, \dots, c_d\}$ - набор значений, для которых $\com = \ACC.\Eval(\pp_\ACC, C)$
	\end{itemize}
\end{definition}

\begin{theorem}
	\label{lemma:7}
	Для любого сколь угодно эффективного злоумышленника $\A$, $E_0(\A) \approx E_1(\A)$ при безопасном акккумяляторе $\ACC$.
\end{theorem}

\begin{proof}
	Заметим, что единственная разница между экспериментами  $E_0$ и $E_1$ заключается в проверки $c^* \notin C$.
	Следовательно, если $E_0(\A) = 0$, то $E_1(\A) = 0$ по определению.
	Если $E_0(\A) = 1$ и $c^* \in C$, то $E_1(\A) = 1$.
	Остается последний случай, когда $E_0(\A) = 1$, $c^* \notin C$ и $E_1(\A) = 1$.
	Сконструируем алгоритм $\B$, по которому будет приниматься участие в эксперименте $\ExptACC$ следующим образом:
	\begin{itemize}
		\item По публичным параметрам $\pp = (\pp_\ACC, N, b, d)$ от доверенного лица, вычисляется $(x, t, r, \pi) \leftarrow \A(\pp)$ и $(\wit, \langle v_1, \dots, v_d \rangle) \leftarrow \pi$.
		\item Затем свидетельство $\wit$, элемент $c^* \leftarrow H(H^{t_1}(v_1) || \dots || H^{t_d}(v_d))$ и набор $C$, для которого $\com = \ACC.\Eval(\pp_\ACC, C)$ доверенному лицу.
		\item Доверенное лицо возвращает один бит $z$, который является результатом эксперимента.
	\end{itemize}
	Если $c^* \notin C$ и $E_1(\A) = 1$, то $\ExptACC(\B) = 1$ по определению.
	Таким образом, обозначив $\epsilon$ как наибольшее преимущество всех возможных злоумышленников, учавствующих в эксперименте $\ExptACC$, получим $|\Pr[E_0(\A) = 1] - \Pr[E_1(\A) = 1]| \leq \epsilon$, что доказывает теорему.
\end{proof}

\begin{theorem}
	\label{lemma:8}
	Для сколь угодно эффективного злоумышленника $\A$, величина $\Pr[E_1(\A) = 1] \leq \epsilon$, где $\epsilon$ - вероятность найти коллизию для $H$.
\end{theorem}

\begin{proof}
	% TODO
\end{proof}

\begin{theorem}
	\label{lemma:6}
	Основная конструкция $HW$, на основе устойчивой к коллизиям хеш-функции $H$ и безопасного аккумулятора $ACC$, удовлетворяет обязательно-условной корректности.
\end{theorem}

\begin{proof}
	Заметим, что $E_0$ точно совпадает с \ref{definition:3}.
	Следовательно, доказательство вытекает из \ref{lemma:7} и $\ref{lemma:8}$.
\end{proof}

\begin{definition}[Симулятор]
	Симулятор $Sim$: $PP \times [N] \rightarrow \P \times \C$, получающий на вход публичные параметры $\pp \in PP$, целое положительное пороговое значение $t \in [N]$ и возвращающий набор $(\pi, \com) \in \P \times \C$, определяется следующим образом:
	\begin{enumerate}
		\item Используя $(\pp_\ACC, N, b, d) \leftarrow \pp$, выбираются случайный индекс $i^* \leftarrow_R [d]$, $d - 1$ значение $c_1, \dots, c_{i^* - 1}, c_{i^* + 1}, \dots, c_d \leftarrow_R \{0, 1\}^\lambda$ и значения $v_1, \dots, v_d \leftarrow_R \{0, 1\}^\lambda$.
		\item Для каждого $j \in [d]$, определяется $c_{i^*} \leftarrow H(H^{t_1}(v_1) || \dots || H^{t_d}(v_d))$, где $t_1 \dots t_d$ - разложением порогового значения $t$ по основанию $b$.
		\item Используя $C = \{c_1, \dots, c_d\}$, вычисляются $\wit \leftarrow (\ACC.\WitCreate(\pp_\ACC, c_{i^*}, C), \wit \leftarrow (\wit, \langle v_1, \dots, v_d \rangle), \com \leftarrow \ACC.\Eval(\pp_\ACC, C))$ и возвращает $(\pi, \com)$.
	\end{enumerate}
\end{definition}

\begin{definition}[Распределения $D_0$, $D_1$, $D_2$ и $D_3$]
	Определим следующую серию распределений:
	\begin{itemize}
		\item $D_0$: равнозначно распределению $(\pp, Sim(t), x, t)$.
		\item $D_1$: подобно $D_0$, за исключением метода генерации значений $v_1, \dots, v_d$. Вместо того, чтобы равномерно выбирать их из $\{0, 1\}^\lambda$, выбирается $r^* \leftarrow_R \{0, 1\}^\lambda$. Пусть $\langle w_1, \dots, w_m \rangle \leftarrow \MDP_b(x)$ и $i^* \in [m]$ - первый индекс, такой что $w_{i^*}$ доминирует над $t$. Обозначив $y_1 \dots y_d$ и $t_1 \dots t_d$ как разложение по основанию $b$ чисел $w_{i^*}$ и $t$ соответственно, определим $v_j \leftarrow H^{y_j - t_j}(H((i^*, j) || r^*)$. Все остальные шаги остаются неизменными.
		% TODO [d] \ {i*} - знак \
		\item $D_2$: подобно $D_1$, за исключением метода генерации значений $c_1, \dots, c_{i^* - 1}, c_{i^* + 1}, \dots, c_d$. Вместо того, чтобы равномерно выбирать их из $\{0, 1\}^\lambda$, выбирается $r \leftarrow_R \{0, 1\}^\lambda$, для каждого $i, j \in [d]$ вычисляется $r_{i, j} \leftarrow H((i, j) || r)$ и $\langle w_1, \dots, w_m \rangle \leftarrow \MDP_b(x)$, используя $H$ и $r$ выбирается перестановка $P'$: $[d] / \{i^*\} \rightarrow [d] / \{i^*\}$, и для каждого $i \in [d] / \{i^*\}$, зафиксировать $a_i \leftarrow \HWS_d(w_r; r_i)$ и $c_i \leftarrow a_{P'(i)}$. Все остальные шаги остаются неизменными.
		\item $D_3$: равнозначно распределению $(\pp, (\Prove(\pp, x, r; r), \Commit(\pp, x; r)), x, t)$.
	\end{itemize}
\end{definition}

\begin{theorem}
	\label{lemma:10}
	Для любого сколь угодно эффективного злоумышленника, который различает $D_0$ и $D_1$ с вероятностью не больше $\epsilon$, существует злоумышленник, который взламывает безопасную случайность $G$ или $H$ с вероятностью не менее $\frac{\epsilon}{(b + 1) \cdot d}$.
\end{theorem}

\begin{proof}
	% TODO
\end{proof}

\begin{theorem}
	\label{lemma:11}
	Для любого сколь угодно эффективного злоумышленника, который различает $D_1$ и $D_2$ с вероятностью не больше $\epsilon$, существует злоумышленник, который взламывает безопасную случайность $H$ с вероятностью не менее $\frac{\epsilon}{b \cdot d \cdot (d - 1)}$.
\end{theorem}

\begin{proof}
	% TODO
\end{proof}

\begin{theorem}
	\label{lemma:12}
	Распределения $D_2$ и $D_3$ идентичны.
\end{theorem}

\begin{proof}
	% TODO
\end{proof}

\begin{theorem}
	\label{lemma:9}
	Основная конструкция $HW$, основанная на безопасно случайной хеш-функции $H$, удовлетворяет условию неразличимости свидетелей.
\end{theorem}

\begin{proof}
	% TODO
\end{proof}

\begin{theorem}
	\label{theorem:2}
	Основная конструкция $\HW$ является безопасным $CBRP$, основанным на том, что $H$ - устойчивая к коллизияим и безопасно случайная хеш-функция и $\ACC$ - безопасный аккумулятор.
\end{theorem}

\begin{proof}
	Из \ref{lemma:4}, \ref{lemma:5}, \ref{lemma:6} и \ref{lemma:9} следует доказательство теоремы.
\end{proof}
