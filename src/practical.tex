\chapter{Практическая часть}
Для оценки практической применимости основной конструкции, данный протокол был реализован на языке программирования Rust на основе различных криптографических примитивов.
Выбор языка программирования Rust для реализации данного протокола обусловлен несколькими ключевыми факторами, среди которых особенно выделяется безопасность:
\begin{itemize}
	\item Rust предлагает строгую систему управления памятью, которая предотвращает распространенные ошибки, такие как утечки памяти, использование неинициализированной памяти и гонки данных. Это достигается благодаря концепциям владения, заимствования и времени жизни (lifetimes), которые позволяют компилятору проверять корректность работы с памятью на этапе компиляции. В контексте криптографии, где ошибки могут привести к уязвимостям и компрометации данных, такая безопасность является критически важной. Кроме того, Rust минимизирует необходимость в ручном управлении памятью, что снижает риск ошибок, связанных с неправильным освобождением ресурсов. Это особенно важно для криптографических приложений, где надежность и безопасность кода имеют первостепенное значение.
	\item Rust обеспечивает высокую производительность, сопоставимую с языком программирования C. Это позволяет эффективно реализовывать криптографические алгоритмы и оптимизации, что критично для достижения хорошей производительности протокола. Оптимизация кода в Rust позволяет использовать низкоуровневые возможности языка, не жертвуя при этом безопасностью.
	\item Rust также поддерживает кросс-платформенную разработку, что делает его удобным выбором для создания приложений, которые могут работать на различных устройствах, включая слабые устройства. Это особенно важно для криптографических протоколов, которые могут использоваться в мобильных приложениях или встроенных системах, где ресурсы ограничены.
\end{itemize}

Для тестов и сравнение использовались следующие криптографические примитивы:
\begin{itemize}
	\item Хеш-функция: Streebog256, Streebog512, Blake2, Blake3, SHA256 и SHA512.
	\item Аккумулятор: разреженное дерево Меркла.
	\item Метод генерации случайной перестановки: тасование Фишера-Йетса \cite{10.1145/364520.364540}.
\end{itemize}

\section{Оптимизация}
% Самая очевидная оптимизация основной конструкции заключается в изменении основания для разложения, которое прямопропорционально времени генерации доказательства и обратнопропорционально времени проверки доказательства.
% В крайнем случае, когда $b = N$, конструкция эквивалентна PayWord \cite{10.1007/3-540-62494-5_6}, с доказательствами постоянного размера, но экспоненциальной сложности времени доказательства и проверки.
% С другой стороны, при $b = 2$, обеспечивается высокая параллелизация операций для доказывающего и проверяющего за счет увеличения размера доказаельства.
\subsection{Дополнение и усечение}
Основная конструкция не учитывает усечения и дополнения, однако тщательный выбор аккумулятора приводит к более быстрым операциям и значительно более коротким доказательствам без ущерба для безопасности.

Во-первых, существует возможность опустить незначащие нули любого числа по основанию $b$ до максимума $N$.
Например, число $k = 47$ по основанию $b = 10$ при $N = 999999$.
Данное число раскладывается как $0 \cdot b^5 + 0 \cdot b^4 + 0 \cdot b^3 + 0 \cdot b^2 + 4 \cdot b^1 + 7 \cdot b^0$ и обычно требует шесть независимых хеш-цепей, по одной для каждой десятичной цифры.
Однако, опустив незначащие нули, потребуется всего две хеш-цепи.
Тем не менее, важно отметить, что независимо от логики усечения, доказательство не должно раскрывать размер числа (степень полинома), и поэтому следует выбрать специальный аккумулятор, чтобы скрыть количество хеш-цепей. После рассмотрения различных аккумуляторов для оптимизации размера доказательства рекомендуется использовать дополненный линейный аккумулятор (Padded Linear Accumulator - PLA).
Дополненный линейный аккумулятор определяется как линейный аккумулятор, который, используя упорядоченные множества и дополнения, позволяет сократить результат до одного хеш-значения.

PLA использует усечение незначащих нулей в разложении и подходит для приложений, где:
\begin{enumerate}
	\item порядок вставки элементов имеет значение;
	\item необходимо доказать включение последних $m$ элементов в множество;
	\item доказательства не должны раскрывать размер множества.
\end{enumerate}
Указанные выше свойства точно соответствуют требованиям протокола, так как хеш-цепи упорядочены по значащим цифрам, протокол требует доказательства включения смежных хеш-цепей, количество фактически используемых хеш-цепей в обязательстве не должно быть раскрыто, так как это может привести к утечке информации о размере доказываемого значения.

\begin{definition}[Дополненный линейный аккумулятор $PLA_d(k; r)$]
	Пусть $N$ - наибольшее поддерживаемое протоколом целое число, $k$ - доказываемое значение, $b$ - основание, $d_k = \lceil \log_b(k) \rceil$ и $k_1 \dots k_{d_k} = k$ - разложение по $k$ основанию $b$, где $k_1$ - наиболее значимая цифра.
	Для равномерно сгенерированной битовой строки $r$ функция аккумулятора $Eval$ для составной хеш-цепи, обозначаемая $PLA_d(k; r)$, определяется следующим образом: $PLA_d(k; \langle r_1, \dots, r_d \rangle) = z_d$, где вычисляемое значение $z_d$ зависит от требований к дополнению.
	Если $d_k = d_N$, то дополнение не требуется, поскольку все возможные хеш-цепи уже задействованы и $z_d = \{z_0 \leftarrow H^{k_1}(r_1), z_i \leftarrow (z_{i - 1} || H^{k_{i + 1}}(r_{i + 1}))\}$ для $i \in [1, d_k - 1]$.
	В противном случае элемент дополнения $p$ детерменированно генерируется из выданного секретного ключа и $z_{d_k} = \{z_0 \leftarrow p, z_i \leftarrow (z_{i - 1} || H^{k_i}(r_i))\}$ для $i \in [1, d_k]$.
\end{definition}

Аналогичным образом, существует возможность скрыть количество значений MDP.
Например, при $k = 47$, множество MDP состоит из двух элементов $\langle 47, 39 \rangle$ по основанию $b = 10$.
В лучшем случае, только эти два элемента должны использоваться в вычислениях, но при этом количество этих элементов не должно быть раскрыто.
Это возможно при использовании дополненных детерменированных разреженных деревьев Меркла, которые позволяют эффективно скрывать размер множества MDP и при этом требуют количество хеш-цепей, равное размеру.

При доказательстве включения WitCreate для PLA, доказывающий возвращает результат вышеуказанной функции Eval до $d_k - d_t$, где $t$ - запрашиваемое пороговое значение диапозонного доказательство, которое раскладывается по основанию $b$ как $t_1 \dots t_{d_t}$, и $d_t = \lceil \log_b(t) \rceil$ - количество цифр в числе $t$ по основанию $b$.
Проверяющий может продолжать проверять полученный результат от Eval и вычисленные элементы хеш-цепей $H^{k_i - t_i}(r_i)$.
Следует отметить, поскольку проверяющий получает только результат Eval для первых $d_k - d_t$ элементов, само значение $d_k$ не раскрывается, и, следовательно, количество фактических хеш-цепей остается в секрете.
В противном случае это могло бы привести к утечке информации о выданном значении.

Основное преимущество PLA по сравнению с аккумулятора на основе дереве Меркла заключается в том, что доказательство включения не зависит от $N$ и состоит из одного хеш-значения результата, в то время как для аккумуляторов на основе дерева Меркла ожидается $d_N$ хеш-значений результатов.
Кроме того, как упоминалось выше, основная конструкция вычисляет обязательство составной цепи каждого результата MDP с использованием простого аккумулятора конкатенации хешей $HMC_d(k; r) := H(H^{k_1}(r_1) || \dots || H^{k_d}(r_d))$.
Однако он данный аккумулятор не учитывает дополнения и без PLA необходимо включить $d_N - d_k$ хеш-значений результатов, чтобы скрыть количество хеш-цепей, использованных для кодирования $k$.
Это приводит к значительно более длинным доказательствам, особенно при $t \ll N$.
Чтобы избежать данный момент, рекомендуется вместо $HMC_d$ использовать $PLA.\Eval(\pp_{PLA}, \{H^{k_1}(r_1), \dots, H^{k_d}(r_d)\})$.

\subsection{Детерменированные разреженные деревья Меркла} % 4.1.2 Deterministic Sparse Merkle Trees
Последний шаг генерации обязательства основной конструкции требует вывода аккумулятора для каждого из составной хеш-цепи обязательства $c_i$, который вычисляется как  $\com \leftarrow \ACC.\Eval(\pp_\ACC, \{c_1, \dots, c_d\})$.
Однако примитивная конкатенация всех $c_i$ имеет два основных недостатка эффективности.
Во-первых, следует отметить, что при запросе доказательства фактически выбирается только один путь MDP.
Такой линейный конкатенирующий аккумулятор ожидает присоединения всех значений $c_i$ к доказательству, иначе проверяющий не сможет оценить результат аккумулятора, что приводит в более длинным доказательствам.
Во-вторых, помимо сжатия окончательного обязательства до одного элемента, цель аккумулятора также заключается в скрытии фактического размера списка $\MDP(k)$, $d_k \leftarrow \lceil \log_b(k) \rceil$.
Очевидно, это связано с тем, что $d_k$ раскрывает информацию о значении $k$.
Как было показано выше, $d_k \leq d_N$, следовательно, один из вариантов скрыть $d_k$ является дополнение значений $c_i$ $d_N - d_k$ случайными фиктивными элементами.
Одним из вариантов решения первой проблемы является замена конкатенирующего аккумулятора на дерево Меркла.
Однако данное дерево должно иметь $d_N$, а не $d_k$ листьев, так как высота дерева раскрывает информацию о количестве его листьев и, следовательно, о размере $\MDP(k)$.
Следует отметить, что базовое дерево Меркла требует доказательства включения размером $\log_2(d_N)$, но при этом необходимо вычислить $d_n - d_k$ случайных фиктивных листьев.
Однако, использование подход детерминированного разреженного дерева Меркла (SMTree) из протокола DAPOL \cite{cryptoeprint:2020/468} позволит уменьшить количество дополнительных узлов дополнения.
В таком случае, высота дерева все еще будет $d_n$, но количество узлов будет логарифмическим.

\section{Повторное использование составных хеш-цепей} % 4.2 Reusing Multichains
В базовой версии основной конструкции каждое значение MDP имеет сою собственную независимую составную хеш-цепь и, следовательно, в худшем случае требует $\log^2_b(N)$ хеш-цепей длины $b$.
Это связано с тем, что существует максимум $\log_b(N)$ значений MDP, и каждое целое положительное число MDP кодируется с помощью не больше чем $\log_b(N)$ хеш-цепей.
Рисунок \ref{fig:1} иллюстрирует простой пример такой ситуации.

\begin{tikzpicture}[node distance=1.5cm]
	\label{fig:1}
	% TODO
\end{tikzpicture}

Однако факт того, что доказательства используются один раз, позволяет использовать значения одной составной хеш-цепи.
Данная техника представлена на рисунке \ref{fig:2}.
В результате требуется только $\log_b(N)$ хеш-цепей, что снижает затраты на создание обязательств и доказательств в $\log_b(N)$ раз, что для основания $256$ подразумевает почти в восемь раз более быструю конструкцию.

\begin{tikzpicture}[node distance=1.5cm]
	\label{fig:2}
	% TODO
\end{tikzpicture}

Однако совместное использование составной хеш-цепи не обходится без затрат.
Как уже упоминалось, размер списка MDP должен оставаться конфиденциальным, поскольку это может раскрыть информацию о структуре секретного значения.
Как указано на рисунке \ref{fig:2}, предполагая, что запрашивается доказательство меньшее или равное 301, доказывающий обычно выбирает путь $\com_{303}$, так как $303$ - наименьшее значение MDP, большее чем $301$.
Таким образом, доказательство должно содержать следующий список узлов $L = [seed_A, seed_B, h^2(seed_C)]$.
Честный проверяющий трижды хеширует $seed_A$, использует $seed_B$ напрямую и хеширует $h^2(seed_C)$ один раз, чтобы получить все необходимое для вычисления $\com_{303}$.
Однако злоумышленник в качестве проверяющего может перебором определить количество повторных хеширований для различных комбинаций, пока не достигнет другого значения MDP.
В данном примере, если злоумышленник хеширует $seed_A$ дважды, $seed_B$ трижды и $h^2(seed_C)$ один раз, то получается $\com_{233}$.
В результате полный размер $L$ оказывается раскрытым.

Для защиты от вышеописанного сценария, вводится дополнительное значение соли, чтобы затемнить корень каждого обязательства MDP перед его использованием в качестве входных данных для результирующего аккумулятора.
Это означает, что каждое доказательство должно сопровождаться дополнительным значением соли (обычно достаточно 16 байт), и результирующий аккумулятор при генерации обязательства должен принимать в  качестве входных данных $\com \leftarrow \ACC.\Eval(\pp_\ACC, \{PRF(c_1, salt_1), \dots, PRF(c_d, salt_d)\})$, где в качестве кандидата на PRF можно использовать HMAC или функцию формирования ключа (Key Derivation Function - KDF).
Благодаря наличию соли вышеописанная атака не может быть применена, поскольку доказательство включает соль только для предполагаемого значения MDP, и, следовательно, злоумышленник не может вычислить или предсказать результат PRF для любого другого перебираемого пути MDP, необходимого для оценки окончательного аккумулятора.

\section{Замеры и сравнения}
Обозначив основание $b$ и верхний предел используемых целых положительных чисел как $N$, основанная конструкция асимптотически имеет следующие параметры:
\begin{itemize}
	\item $\O(1)$ - размер обязательства,
	\item $\O(\log_b(N))$ - размер доказательства,
	\item $\O(\log_b(N))$ - время генерации и проверки доказательства.
\end{itemize}

\subsection{Сравнение размера доказательства} % 4.3.1 Comparing Proof Size
Для эффективной генерации обязательства требуется максимум $\log_b(N)$ хеш-цепей размера $b$.
Затем используется аккумулятор на основе дерева Меркла для создания корня перемешанных частей обязательства для каждого значения MDP.

В худшем случае, когда дополнение не применяется, общий размер для одного доказательства составляет $\log_b(N) + \log_2(\log_b(N))$ хеш-элементов.
При $n \leq 128$, в зависимости от выбора основания, в сравнении с благоприятным классическим протоколом Bulletproofs, генерирующим доказательство размером $2 \cdot \log_2(\log_2(N)) + 9$ элементов эллиптической кривой на основе обязательства Педерсена.
Обычно, один сжатый элемент эллиптической кривой составляет $32$ байта, что эквивалентно $256$-битному хеш-значению.
Обратим внимание, что финальная оптимизация требует как минимум $16$ дополнительных байт для MDP-соли и $1$ байт для кодирования индекса листа, необходимого для окончательного пути включения в разреженный аккумулятор дерева Меркла.
Результаты замеров приведены в таблице \ref{table:1}.
Сравнение размеров также включает систему доказательства с нулевым разглашением Groth16 \cite{cryptoeprint:2016/260} на основе доверенной настройки на кривой BLS12-381 с постоянным размером доказательства.
Заметим, что основная конструкция по основанию $2048$ производит более компактные доказательства, чем Groth16 в 32-битных областях.

\begin{table}[h]
	\centering
    \begin{tabular}{|c|c|c|c|c|c|c|}
        \hline
        n   & BPs & G16 & $HW_4$  & $HW_{16}$ & $HW_{256}$ & $HW_{2048}$ \\ \hline
        16  & 544 & 192 & 369     & 209       & 113        & 113         \\ \hline
        32  & 608 & 192 & 657     & 369       & 209        & 177         \\ \hline
        64  & 692 & 192 & 1201    & 657       & 369        & 305         \\ \hline
        128 & 736 & 192 & 2257    & 1201      & 657        & 529         \\ \hline
    \end{tabular}
	\label{table:1}
	\caption{Сравнение результатов доказательств диапазона (в байтах). $HW_b$ обозначает основную конструкцию по основанию $b$ и параметром безопасности $\lambda = 128$, BPs - Bulletproofs и G16 - Groth16.}
\end{table}

Данные результаты были получены при параметре безопасности $128$ бит.
Дальнейшие улучшения размера доказательства могут быть достигнуты путем построения основной конструкции на основе псевдослучайных функций, что потенциально позволит полагаться на меньшие общие размеры результатов для каждого компонента доказательства.

\subsection{Вычислительная эффективность} % 4.3.2 Computational Efficiency
Оптимизированная основная конструкция реализована на языке программирования Rust с применением аккумуляторов PLA и разреженного дерева Меркла.
Сравнения вычислительной эффективности были произведены для основной конструкции по основанию $16$ и $256$ и с самой быстрой доступной реализацией Bulletproofs на языке программирования Rust.
Также для Bulletproofs были произведены замеры при использовании AVX2, который реализует арифметику эллиптических кривых с использованием параллельных формул через векторизированные инструкции, чтобы обеспечить прозрачность сравнения с оптимизированными реализациями диапазонных доказательства.

Таблица \ref{table:2} отображает затраты в микросекундах при запуске замеров на 6-ядерном 2.3GHz AMD Ryzen 5 4500U с 8GB оперативной памяти.

\begin{table}[h]
	\centering
    \begin{tabular}{|l|c|c|c|c|c|c|}
        \hline
		Схема               & $\com_{gen}$ & $proof_{gen}$ & $proof_{ver}$ \\ \hline
        BPs                 & 71           & 12099         & 1555          \\ \hline
        BPs AVX2            & 36           & 6516          & 938           \\ \hline
        $HW_{16}$  SHA2-256 & 274          & 278           & 84            \\ \hline
        $HW_{256}$ SHA2-256 & 651          & 656           & 619           \\ \hline
        $HW_{16}$  Blake3   & 101          & 103           & 31            \\ \hline
        $HW_{256}$ Blake3   & 260          & 263           & 230           \\ \hline
    \end{tabular}
	\label{table:2}
	\caption{Сравнение эффективности (в микросекундах) между Bulletproofs (BPs) с поддержкой AVX2 и без нее, а также основной конструкцией для различных оснований и хеш-функций.}
\end{table}

