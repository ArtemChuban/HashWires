\documentclass[a4paper]{article}
\usepackage{amssymb}
\usepackage{amsmath}
\usepackage{fontspec}

\setmainfont{Times New Roman}
\newcommand{\C}{\mathbb{C}}
\renewcommand{\P}{\mathbb{P}}
\newcommand{\com}{\text{com}}
\sloppy
\hbadness=10000

\begin{document}
	\section{Введение}
	Доказательство диапазона - это особый тип доказательства с нулевым разглашением (ZKP - Zero Knowledge Proof) (ref:22), предназначенное для подтверждения того, что зафиксированное целое число находится в пределах некоторого интеравала, не раскрывая при этом никакой дополнительной информации о самом числе.
	% TODO: Имя на русском?
	Gregory Maxwell использовал докательства подобного рода для достижения конфиденциальных транзакций (ref:27), сумма которых скрыта в обязательстве Педерсена, а доказательство диапазона позволяет проверяещему убедиться, что она находится в неотрицательном интервале.
	Доказательства диапозона с нулевым разглашением впервые были предложены в работах Дамгорда (ref:17), Фудзисаки и Окамото (ref:21), а с более практическими конструкциями у Бодута (ref:4), Камениша и других (ref:9), и, что особенно примечательно, Bulletproofs от Бюнца и других (ref:8).

	Типичное доказательство диапазона с нулевым разглашением (ZKRP - Zero Knowledge Range Proof) включает в себя криптографические обязательство (commitment) и доказательство (proof).
	Обязательство должно удовлетворять условиям, известным как сокрытие (hiding) и навязывание (binding), а доказательство должно соответствовать требованиям полноты (completness), корректности (soundness) и нулевого разглашения (zero-knowledge).
	ZKRP использовались для создания приватных транзакций в блокчейнах (например, предложение Gregory Maxswell по обеспечению конфиденциальных транзацкий (ref:27) и MimbleWimble (ref:32)) и для смарт-контрактов на Ethereum, обеспечивающих конфиденциальность.
	Также было предложени использовать их для обработки доказательств платежеспособности (ref:13,16), обеспечения конфиденциальности в системаъ электронных голосований и аукционов, а также ждя анонимных удостоверений (ref:29).

	Некоторые практические приложения ZKRP существуют в контексте, в котором некоторое доверенное лицо выступает в качестве авторитета для создания или проверки обязательств по целым значениям.
	В качестве иллюстративного примера рассмотрим ситацию, в которой гражданин хочет доказать поставщику услуг, что его возраст превыщает определенный порог, не раскрывая при этом свою дату рождения (ref:6,18).
	Доверенное лицо (например, государственный орган, выдающий удостоверения личности) может выдать заявление, подтверждающее возраст доказывающего, который в свою очередь имеет возможность использовать протокол ZKRP для создания доказательства, которое убедит проверябщего в том, что его возраст действительно превышает запрашиваемый порог.

	Не смотря на то, что вышеописанный сценарий можно решить при помощи существующих конструкций ZKRP, таких как Bulletproofs или обязательство Педерсена, эти решения часто оказываются менее практичными в условиях ограниченных ресурсов, где ассиметричные криптографические примитивы считаются дорогими.
	В приложениях, где эти доказательства необходимо генерировать и проверять очень часто, более простые и легковесные примитивы могут стать привлекательной альтернативой для условий, в которых существует доверенная сторона, генерирующая обязательства.

	В частности, можем ли мы использовать предположение о том, что проверяющий доказательства диапазона может доверять тому, что обязательство было сгенерированно честно, чтобы получить более простые и эффективные конструкции.
	Чтобы учесть дополнительное требование доверенное стороны, введем доказательство диапазона на основе удостоверений (CBRP - Credential-Based Range Proof), которое отличается от ZKRP двумя пунктами:
	- Требование корректности упрощено до более слабого его варианта - обязательно-условная корректность (commitment-conditional soundness)
	- Требование нулевого разглашения упрощено до более слабого его варианта - неразличимость свидетелей (witness indistinguishability)

	Чтобы интуитивно понять эти ослабленния требований к безопасности для CBRP, начнем с описания простой схемы на основе хеширования для доказательств диапазона, изначальное представленной Rivest и Shamir (ref:33) в протоколе, известном как PayWord (с адаптациями).
	Дано две устойчивые к коллизиям хеш функции $G$ и $H$, и целое число $N$, отображающее максимально возможное значение области.
	Эмитент создает обязательство $c$ для некоторого секретного целого числа $k \in [0, N]$, выбирая случайное начальное значение $r$, рассчитывая $c = H^k(G(r))$, где $H^k(\cdot)$ - $k$ последовательных применений функции $H$, и размещает $c$ в публичном месте или отправляет подписанное $c$ доказывающему напрямую.
	Эмитент отправляет случайное начальное значение $r$ и целое число $k$ доказывающему, который сможет создать доказательство диапозона на основе $r$ для некоторого порогового значение $t$, вычислив $\pi = H^{k - t}(G(r))$ и отправив $\pi$ проверяющему.
	Проверяющий проверяет, что $H^t(\pi) = c$, чтобы убедиться, что $c$ является обязательством некоторого значения $x \geq t$.

	% TODO: ceil
	Несмотря на свою простоту, PayWord имеет значительный недостаток: пусть $n = ceil(\log_2 N)$ - количество бит, необходимых для представления размера области $N$.
	Обратим вниманием, что генерация обязательства и доказательства, а также их проверка имеют асимптотически экспоненциальную сложность по отношению к $n$.
	Таким образом, использование PayWord в качестве CBRP в действительности подходит только для областей малых размеров, а его производительность для больших диапозонов вряд ли будет конкурентоспособной по сравнению с общими ZKRP.

	Совершенно другой подход с построению CBRP для областей больших размеров без использования ZKRP включает в себя применение закодированных схем.
	Для некоторого секретного целого числа $k \in [0, N]$, эмитент может создать обязательство, представляющее собой хеш закодированное схемы $C$, которая вычисляется как $C(k, y) = 1$, если $k \geq y$ и $0$ в противном случае, вместе с обязательствами для случайных значений, каждое из которых связанно с одним из входов сети.
	Доказывающий, с некоторым взодным пороговым значением $t$, генерирует доказательство, которое состоит из закодированное из закодированной схемы $C$, а также раскрывает случайные значения, относящиеся к входам сети для битового представления $t$.
	Проверящий может убедиться, что открытые обязательства соответствуют правильным битам $t$, хеш закодированных схем соответствует том, что содержится в финальном обязательстве, и вычисление закодированной схемы возвращает ожидаемый результат.
	Интуитивно, обязательно-условная корректность вытекает из корректности схемы кодирования, а неразличимость свидетелей следует из конфиденциальности самой закодированной схемы.
	Это решение явно обобщается на произвольные схемы, вместо того, чтобы быть ограниченным только обработкой доказательств диапазона, но размер доказательств в данной схеме довольно велик, в основном из-за того, что оно должно содержать полное описание закодированной схемы.
	Таким образом, хотя этот подход технические имеет возможность обрабатывать взодные данные большего диапазона, которые PayWord не мог, все же существует значительное пространство для усовершенствований.

	% TODO: 1.1 Our Contributions
	% TODO: 1.2 Related Work

	\section{Теоретическая часть}
	\subsection{Введение в основные понятия} % 2 Preliminaries
	В данной работе, $\lambda$ обозначает параметр безопасности.
	Для целого положительного числа $N$, $[N]$ обозначает набор целых положительных чисел $\{1, 2, \dots, N\}$.
	Для двух целых положительных чисел $a$ и $b$, таких что, $a < b$, запись $[a, b]$ обозначает набор целых положительных чисел $\{a, a + 1, \dots, b\}$.
	Будем называть алгоритм эффективным, если по отношению к $\lambda$ он работает за полиномиальное время.
	Величину, обратно пропорциональную полиномиальному значению по отношению к $\lambda$, назовем незначительной.
	% TODO: Проверить \approx
	Для двух распределений $D_1$ и $D_2$ по одной и той де области будем писать $D_1 \approx D_2$, чтобы обозначить вычислительную неразличимость; а именно, для любого сколь угодно эффективного противника, который получает на вход образец и выводит по нему бит, разница в вероятности того, что противник выведит $1$ при получении образца из $D_1$, и вероятности того, что противник выведит $1$ при получении образца из $D_2$, незначительна.
	Вышеуказанную величину назовем преимуществом противника в различении $D_1$ и $D_2$.

	% TODO: Проверить <>
	Обозначим битовую строку произвольной длины как $\{0, 1\}^*$.
	Операцию конкатенации строк обозначим как $||$.
	Для целого положительного числа $n$, обозначим упорядоченную последовательность набора элементов $\{a_1, \dots, a_n\}$ как $<a_1, \dots, a_n>$.

	Запись $y_{i, 1}, \dots, y_{i, d}$ обозначает представление целого положительного $d$-значного числа $y_i$ по основанию $b$.

	\subsubsection{Доказательство диапазона на основе удостоверений} % 2.1 Credential-Based Range Proofs
	% TODO: Проверить \C, |P, \Pi. Добавить \text?
	Для фиксированного целого положительного числа $N$, пространства обязательств $\C$, пространства доказательст $\P$ и пространства случайнойсти $\{0, 1\}^\lambda$, неинтерактивный CBRP представляет собо набор алгоритмов $\Pi = (Setup, Commit, Prove, Verify)$ со следующими свойствами:
	- $Setup(1^\lambda) \rightarrow pp$. Алгоритм установки на основе параметра безопасности $\lambda$ генерирует публичные параметры $pp$.
	- $Commit(pp, x; r) \rightarrow com$. Алгоритм обязательства на основе публичных параметров $pp$, целого положительного числа $x \in [N]$ и случайной битовой строки $r \in \{0, 1\}^\lambda$ генерирует обязательство $\com \in \C$.
	- $Prove(pp, x, t; r) \rightarrow \pi$. Алгоритм доказательства на основе публичных параметров, целого положительного числа $x$, порогового значения $t \in [N]$ и случайной битовой строки $r \in \{0, 1\}^\lambda$ генерирует доказательство $\pi$.
	- $Verify(pp, com, t, \pi) \rightarrow z$. Алгоритм проверки на основе публичных параметров, обязательства $\com \in C$, порогового значения $t \in [N]$ и доказательства $\pi$ генерирует бит $z \in \{0, 1\}$.

	% TODO: Security

	% TODO: Definition (Навязывающее обязательство)
	% TODO: Обозначение злоумышленника (\A?)
	Обязательство для $CBRP$ назвыается навязывающим если для любого сколь угодно эффективного злоумышленника $A$, который получает публичные параметры $pp \leftarrow Setup(1^\lambda)$ и генерирует пару раличных целых положительных чисел $x_0, x_1 \in [N]$, пару случйаный битовых строк $r_0, r_1 \in \{0, 1\}^\lambda$ и два обязательства $com_0 \leftarrow Commit(pp, x_0; r_0)$ и $com_1 \leftarrow Commit(pp, x_1; r_1)$, величина $Pr[com_0 = com_1]$ незначительна по отношению к $\lambda$.

	% TODO: Definition (Идеальная? полнота)
	% TODO: Обозначение злоумышленника (\A?)
	CBRP удовлетворяет (идеальной?) полноте если любой сколь угодно эффективный злоумышленник $A$, генерирующий $x, t \in [N]$, причем  $x \geq t$, и $r \in \{0, 1\}^\lambda$, будет получать $Verify(Commit(x; r), t, Prove(x, t; r)) = 1$.

	% TODO: Definition (Обязательно-условная корректность)
	% TODO: Обозначение злоумышленника (\A?)
	CBRP удовлетворяет обязательно-условной корректности если для любого сколь угодно эффективного злоумышленника $A$, который на основе публичных параметров $pp \leftarrow Setup(1^\lambda)$ генерирует набор $(x, t, r, \pi) \in [N] \times [N] \times \{0, 1\}^\lambda \times \P$, где $x < t$, вероятность $Verify(pp, Commit(pp, x; r), t, \pi) = 1$ незначительна по отношению к $\lambda$.

	\bibliographystyle{plain}
	\bibliography{references}
\end{document}
